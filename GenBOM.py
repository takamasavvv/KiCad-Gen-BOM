import xml.etree.ElementTree as ET
import re
import csv
import json

component = ".//comp"
desig_ptn = re.compile(r'[a-zA-Z][a-zA-Z]?')


def define_config():
    """import config file(conf.json)"""
    with open("./conf.json", 'r') as conf:
        config = json.load(conf)[0]  # load config dict
        config['project']['bom'] = \
            config['BOM'][config['project']['bom']]  # set bom format
        return config['project']


def extract_parts(xml_dir):
    """extract parts data from xml file(generated by KiCad)"""
    parts_list = []
    tree = ET.parse(xml_dir)
    root = tree.getroot()
    for comp in root.iter('comp'):  # make part dict from <comp></comp> in xml
        part = {}
        part['ref'] = comp.attrib['ref']
        for field in comp.iter('field'):
            if field.text in '-':  # if field doesnt has data
                part[field.attrib['name']] = None
            else:
                part[field.attrib['name']] = field.text
        parts_list.append(part)
    return parts_list


def gen_unite_list(parts_list, project):
    """unite designator from same parts"""
    mapping = project['bom']['mapping']
    comp_list = []
    unite_list = []
    for part in parts_list:
        comp_part = \
            {v[0]: part[v[1]] for v in mapping.items() if v[1] is not None}
        # - extract compare factor
        if comp_part not in comp_list:  # if comp_part isnt exist in comp_list
            unite_list.append([comp_part, [part['ref']], 1])
            comp_list.append(comp_part)
        else:
            num = comp_list.index(comp_part)  # set part position
            unite_list[num][1].append(part['ref'])  # append designator
            unite_list[num][2] += 1  # add quantity
    return unite_list


def modify_line(unite_line):
    """modify to writable dict for csv"""
    sorted(unite_line[1], key=lambda x: int(desig_ptn.split(x)[1]))
    # - sort desig list
    unite_line[0]['Designator'] = ','.join(unite_line[1])
    # - change from designator list to a str
    unite_line[0]['Quantity'] = unite_line[2]
    mod_line = unite_line[0]
    return [desig_ptn.match(unite_line[1][0]).group(), mod_line]
    # - [desig_sign, part_line]


def gen_bom_list(mod_list):
    """generate BOM list"""
    mod_list.sort(key=lambda desig: desig[0])  # sort by desig_sign
    return [bom_line[1] for bom_line in mod_list] #BOM list


def main():
    """main"""    
    project = define_config()
    prj_dir = project['dir'] + project['name'] + "/"
    rows = extract_parts(prj_dir + project['name'] + ".xml")
    mod_list = [modify_line(i) for i in gen_unite_list(rows, project)] 
    # - list <- [desig_sign, part_line]
    bom_file = prj_dir + project['name'] + "-BOM" + ".csv"
    with open(bom_file, 'w', newline='\n') as ds:
        writer = csv.DictWriter(ds, project['bom']['column'])
        # - write according to format
        writer.writeheader()
        for row in gen_bom_list(mod_list):
            writer.writerow(row)


if __name__ == '__main__':
    main() 